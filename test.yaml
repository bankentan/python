package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	"k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	admissionWebhookAnnotationStatusKey = "env-injector-webhook.stable.example.com/status"
)

func main() {
	http.HandleFunc("/mutate", serveMutate)
	http.HandleFunc("/healthz", serveHealthz)

	fmt.Println("Starting server...")
	err := http.ListenAndServeTLS(":8443", "/path/to/tls.crt", "/path/to/tls.key", nil)
	if err != nil {
		panic(err)
	}
}

func serveMutate(w http.ResponseWriter, r *http.Request) {
	admissionReviewReq := v1.AdmissionReview{}
	admissionReviewResp := v1.AdmissionReview{}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to read request body: %v", err), http.StatusBadRequest)
		return
	}

	if err := json.Unmarshal(body, &admissionReviewReq); err != nil {
		http.Error(w, fmt.Sprintf("Failed to unmarshal request: %v", err), http.StatusBadRequest)
		return
	}

	pod := corev1.Pod{}
	if err := json.Unmarshal(admissionReviewReq.Request.Object.Raw, &pod); err != nil {
		http.Error(w, fmt.Sprintf("Failed to unmarshal pod: %v", err), http.StatusBadRequest)
		return
	}

	// Add env vars to pod spec
	pod.Spec.Containers[0].Env = append(pod.Spec.Containers[0].Env, corev1.EnvVar{
		Name:  "MY_ENV_VAR",
		Value: "my-env-var-value",
	})

	admissionReviewResp.Response = &v1.AdmissionResponse{
		Allowed: true,
		Result: &metav1.Status{
			Status: "Success",
		},
		Patch: calculatePatch(&pod),
		PatchType: func() *v1.PatchType {
			pt := v1.PatchTypeJSONPatch
			return &pt
		}(),
	}

	admissionReviewResp.Response.UID = admissionReviewReq.Request.UID

	respBytes, err := json.Marshal(admissionReviewResp)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to marshal response: %v", err), http.StatusInternalServerError)
		return
	}

	if _, err := w.Write(respBytes); err != nil {
		http.Error(w, fmt.Sprintf("Failed to write response: %v", err), http.StatusInternalServerError)
		return
	}
}

func calculatePatch(pod *corev1.Pod) []byte {
	patch := []map[string]interface{}{}

	for _, container := range pod.Spec.Containers {
		containerPatch := map[string]interface{}{
			"op":    "add",
			"path":  fmt.Sprintf("/spec/containers/%d/env", containerIndex(pod, container)),
			"value": []map[string]string{{"name": "MY_ENV_VAR", "value": "my-env-var-value"}},
		}
		patch = append(patch, containerPatch)
	}

	patchBytes, err := json.Marshal(patch)
	if err != nil {
		panic(fmt.Errorf("Failed to marshal patch: %v", err))
	}

	return patchBytes
}

func containerIndex(pod *corev1.Pod, container corev1.Container) int {
	for i, c := range pod.Spec.Containers {
		if c.Name == container.Name {
			return i
		}
	}
	return -1
}

func serveHealthz(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("ok"))
}
