package main

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "net/http"
    "os"
    "strconv"
)

const (
    certFile = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    port     = 443
)

type Pod struct {
    Metadata struct {
        Name      string `json:"name"`
        Namespace string `json:"namespace"`
    } `json:"metadata"`
    Spec struct {
        Containers []struct {
            Name  string            `json:"name"`
            Env   []map[string]Env `json:"env"`
        } `json:"containers"`
    } `json:"spec"`
}

type Env struct {
    Name  string `json:"name"`
    Value string `json:"value"`
}

func main() {
    http.HandleFunc("/mutate", handleMutate)
    err := http.ListenAndServeTLS(":"+strconv.Itoa(port), certFile, certFile, nil)
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}

func handleMutate(w http.ResponseWriter, r *http.Request) {
    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "Error reading request body", http.StatusBadRequest)
        return
    }

    var pod Pod
    if err := json.Unmarshal(body, &pod); err != nil {
        http.Error(w, "Error parsing request body", http.StatusBadRequest)
        return
    }

    for i, container := range pod.Spec.Containers {
        envVar := make(map[string]Env)
        envVar["HTTPS_PROXY"] = Env{"HTTPS_PROXY", "egress"}
        pod.Spec.Containers[i].Env = append(container.Env, envVar)
    }

    patchedPod, err := json.Marshal(pod)
    if err != nil {
        http.Error(w, "Error generating response body", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    w.Write(patchedPod)
}
