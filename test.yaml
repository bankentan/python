package main

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"

	"k8s.io/api/admission/v1beta1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/strategicpatch"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

const (
	admissionWebhookAnnotationValidateKey = "k8s.mutating.webhook/add-env-var"
	admissionWebhookAnnotationStatusKey   = "k8s.mutating.webhook/add-env-var/status"
)

var (
	runtimeScheme = runtime.NewScheme()
	codecs        = serializer.NewCodecFactory(runtimeScheme)
)

func main() {
	log.Printf("Starting Mutating Webhook Server.")

	// Create a Kubernetes client from in-cluster config.
	config, err := rest.InClusterConfig()
	if err != nil {
		log.Fatalf("Failed to create Kubernetes client config: %v", err)
	}
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		log.Fatalf("Failed to create Kubernetes clientset: %v", err)
	}

	// Create a HTTP server to receive admission requests.
	http.HandleFunc("/mutate", func(w http.ResponseWriter, r *http.Request) {
		serveMutate(w, r, clientset)
	})
	server := &http.Server{
		Addr: ":443",
	}
	err = server.ListenAndServeTLS("/etc/webhook/certs/tls.crt", "/etc/webhook/certs/tls.key")
	if err != nil {
		log.Fatalf("Failed to start webhook server: %v", err)
	}
}

func serveMutate(w http.ResponseWriter, r *http.Request, clientset *kubernetes.Clientset) {
	// Read the admission request body.
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Printf("Failed to read request body: %v", err)
		http.Error(w, "Failed to read request body.", http.StatusBadRequest)
		return
	}

	// Parse the admission request.
	admissionReview := v1beta1.AdmissionReview{}
	if _, _, err := codecs.UniversalDeserializer().Decode(body, nil, &admissionReview); err != nil {
		log.Printf("Failed to decode admission request: %v", err)
		http.Error(w, "Failed to decode admission request.", http.StatusBadRequest)
		return
	}

	// Get the pod object from the admission request.
	pod := &corev1.Pod{}
	if err := json.Unmarshal(admissionReview.Request.Object.Raw, pod); err != nil {
		log.Printf("Failed to unmarshal pod object: %v", err)
		http.Error(w, "Failed to unmarshal pod object.", http.StatusBadRequest)
		return
	}

	// Check if the pod needs to be mutated.
	if !mutationRequired(pod) {
		// No need to mutate the pod.
		log.Printf("Pod %s/%s does not require mutation.", pod.Namespace, pod.Name)
		respondAdmissionReview(w, admissionReview)
		return
	}

	// Mutate the pod object.
	mutatedPod := mutatePod(pod)

	// Create a patch to update the pod object.
	patchBytes, err := strategicpatch.CreateTwoWayMergePatch(admissionReview.Request.Object.Raw, mutatedPod, corev1.Pod{})
	if err != nil {
		log.Printf("Failed to create patch for mutated pod: %v", err
		http.Error(w, "Failed to create patch for mutated pod.", http.StatusInternalServerError)
		return
	}

	// Set the patch and patch type in the admission response.
	admissionResponse := v1beta1.AdmissionResponse{
		Allowed: true,
		Patch:   patchBytes,
		PatchType: func() *v1beta1.PatchType {
			pt := v1beta1.PatchTypeJSONPatch
			return &pt
		}(),
	}

	// Set the UID and Kind in the admission response.
	admissionResponse.UID = admissionReview.Request.UID
	admissionResponse.Kind = admissionReview.Request.Kind

	// Create the admission review response.
	admissionReview.Response = &admissionResponse

	// Write the admission review response.
	respondAdmissionReview(w, admissionReview)
}

func mutationRequired(pod *corev1.Pod) bool {
	// Check if the pod has the annotation that enables the mutation.
	annotations := pod.GetAnnotations()
	if annotations == nil {
		return false
	}
	annotationValue := annotations[admissionWebhookAnnotationValidateKey]
	if annotationValue != "enabled" {
		return false
	}
	return true
}

func mutatePod(pod *corev1.Pod) *corev1.Pod {
	// Add the envVar to the container(s) in the pod.
	for i := range pod.Spec.Containers {
		container := &pod.Spec.Containers[i]
		container.Env = append(container.Env, corev1.EnvVar{
			Name:  "MY_ENV_VAR",
			Value: "my-env-var-value",
		})
	}
	return pod
}

func respondAdmissionReview(w http.ResponseWriter, admissionReview v1beta1.AdmissionReview) {
	// Encode the admission review response.
	resp, err := json.Marshal(admissionReview)
	if err != nil {
		log.Printf("Failed to encode admission review response: %v", err)
		http.Error(w, "Failed to encode admission review response.", http.StatusInternalServerError)
		return
	}

	// Write the admission review response.
	if _, err := w.Write(resp); err != nil {
		log.Printf("Failed to write admission review response: %v", err)
		http.Error(w, "Failed to write admission review response.", http.StatusInternalServerError)
		return
	}
}        
        
