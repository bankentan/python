func main() {
	// 将 admissionHandler 函数与 /validate 路径关联起来
	http.HandleFunc("/validate", admissionHandler)

	// 启动服务器
	log.Fatal(http.ListenAndServeTLS(":443", "/path/to/tls/cert", "/path/to/tls/key", nil))
}


------------------------------
package main

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
)

// 定义了一个简单的结构体，用于存储我们要验证的条件，即 pod 中需要有 app=right 的标签以及 HTTP_PROXY 环境变量
type PodSpec struct {
	Labels      map[string]string `json:"labels"`
	Containers  []Container       `json:"containers"`
}

type Container struct {
	Name  string            `json:"name"`
	Env   []EnvVar          `json:"env"`
}

type EnvVar struct {
	Name  string            `json:"name"`
	Value string            `json:"value"`
}

// 简单定义了一个请求处理函数，这里使用的是 http.HandleFunc
func admissionHandler(w http.ResponseWriter, r *http.Request) {
	// 首先读取请求体
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Printf("Failed to read request body: %v", err)
		http.Error(w, "Failed to read request body", http.StatusBadRequest)
		return
	}

	// 解析请求体为 AdmissionReview 结构体
	var admissionReview AdmissionReview
	if err := json.Unmarshal(body, &admissionReview); err != nil {
		log.Printf("Failed to parse AdmissionReview: %v", err)
		http.Error(w, "Failed to parse AdmissionReview", http.StatusBadRequest)
		return
	}

	// 获取 Pod 对象
	pod := admissionReview.Request.Object

	// 验证 Pod 中是否有 app=right 的标签以及 HTTP_PROXY 环境变量
	if !hasRightLabel(pod.Spec.Labels) || !hasHTTPProxy(pod.Spec.Containers) {
		// 如果不符合要求，返回一个 AdmissionResponse，将 allowed 置为 false，并给出一个拒绝的原因
		admissionResponse := AdmissionResponse{
			Allowed: false,
			Result: &Result{
				Message: "Pod does not have app=right label or HTTP_PROXY environment variable",
			},
		}
		writeResponse(w, admissionResponse)
		return
	}

	// 如果验证通过，返回一个 AdmissionResponse，将 allowed 置为 true
	admissionResponse := AdmissionResponse{
		Allowed: true,
	}
	writeResponse(w, admissionResponse)
}

func writeResponse(w http.ResponseWriter, admissionResponse AdmissionResponse) {
	resp, err := json.Marshal(AdmissionReview{
		Response: &admissionResponse,
	})
	if err != nil {
		log.Printf("Failed to serialize response: %v", err)
		http.Error(w, "Failed to serialize response", http.StatusInternalServerError)
		return
	}
	if _, err := w.Write(resp); err != nil {
		log.Printf("Failed to write response: %v", err)
	}
}

// 判断 Pod 中是否有 app=right 的标签
func hasRightLabel(labels map[string]string) bool {
	if val, ok := labels["app"]; ok {
		if val == "right" {
			return true
		}
	}
	return false
}

// 判断 Pod 中是否有 HTTP_PROXY 环境变量
func hasHTTPProxy(containers []Container) bool {
	for _, container := range containers {
		for _, env := range container.Env {
			if env.Name == "HTTP_PROXY" {
				return true
			}
